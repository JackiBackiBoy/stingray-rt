#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : require

#include "includes/bindless.glsl"
#include "includes/geometry_types.glsl"
#include "includes/ray_payload.glsl"
#include "includes/ray_tracing_math.glsl"

layout (location = 0) rayPayloadEXT RayPayload rayPayload;

layout (set = BINDLESS_DESCRIPTOR_SET, binding = BINDLESS_TLAS_BINDING) uniform accelerationStructureEXT g_TLAS;

layout (push_constant) uniform constants {
    uint frameIndex;
    uint rtImageIndex;
    uint sceneDescBufferIndex;
} g_PushConstants;

const uint RAY_BOUNCES = 3;
const uint SAMPLES_PER_PIXEL = 64; // NOTE: Must be a power of 2

void main() {
    const vec2 pixelCoord = vec2(gl_LaunchIDEXT.xy);
    uint rngSeed = uint(pixelCoord.x) + uint(pixelCoord.y) * uint(gl_LaunchSizeEXT.x);
    rayPayload.rngSeed = rngSeed;

    const uint stratumDim = uint(sqrt(float(SAMPLES_PER_PIXEL)));
    const float stratumSize = 1.0 / float(stratumDim);

    vec3 color = vec3(0.0);
    for (uint sy = 0; sy < stratumDim; sy++) {
        for (uint sx = 0; sx < stratumDim; sx++) {
            const vec2 jitter = rand_vec2(rngSeed) * stratumSize;
            const vec2 stratumCoord = pixelCoord + stratumSize * vec2(sx, sy) + jitter;
            const vec2 inUV = stratumCoord / vec2(gl_LaunchSizeEXT.xy);

            vec2 ndcXY = inUV * 2.0 - 1.0;
            ndcXY.y *= -1.0;
            vec4 rayOrigin = g_PerFrameData[g_PushConstants.frameIndex].invViewProjection * vec4(ndcXY, 0.0, 1.0);
            vec4 rayEnd = g_PerFrameData[g_PushConstants.frameIndex].invViewProjection * vec4(ndcXY, 1.0, 1.0);

            rayOrigin.xyz /= rayOrigin.w;
            rayEnd.xyz /= rayEnd.w;

            vec3 rayDir = normalize(rayEnd.xyz - rayOrigin.xyz);

            vec3 sampleColor = vec3(1.0);
            for (uint j = 0; j <= RAY_BOUNCES; j++) {
                // Break if the final bounce has not hit any light source
                if ((RAY_BOUNCES > 0) && (j == RAY_BOUNCES)) {
                    break;
                }

                uint rayFlags = gl_RayFlagsOpaqueEXT;
                traceRayEXT(
                    g_TLAS,         // acceleration structure
                    rayFlags,       // rayFlags
                    0xFF,           // cullMask
                    0,              // sbtRecordOffset
                    0,              // sbtRecordStride
                    0,              // missIndex
                    rayOrigin.xyz,  // ray origin
                    0.001,          // ray min range
                    rayDir,         // ray direction
                    10000.0,        // ray max range
                    0               // payload (location = 0)
                );

                sampleColor *= rayPayload.color;

                if (rayPayload.distance < 0) {				
                    break;
                }

                rayOrigin.xyz += rayPayload.distance * rayDir;
                rayDir = rayPayload.scatterDir;
            }

            color += sampleColor;
        }
    }

    color /= SAMPLES_PER_PIXEL;
    color = pow(color, vec3(1.0/2.2));
    imageStore(
        g_RWTexturesRGBA8[g_PushConstants.rtImageIndex],
        ivec2(gl_LaunchIDEXT.x, gl_LaunchIDEXT.y),
        vec4(color, 1.0)
    );
}